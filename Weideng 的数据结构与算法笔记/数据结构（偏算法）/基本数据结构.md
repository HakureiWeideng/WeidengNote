# 基本数据结构

本笔记只写出要点和注意点，不将数据结构的所有内容写出，详细可见《数据结构（偏工程）》

## 队列

快速清空队列的方法，在一个函数中使用 swap 函数，将其与一个临时空队列交换。

```c++
void clear(std::queue<int> & que) {
    std::queue<int> empty;
    std::swap(empty, que);
    return;
}
```

## 优先队列

（priority queue）

- 优先队列可由堆实现。
- 优先队列常与 BFS 连用，解决权值不等问题。
- 优先队列可以保证一些 dp 的无后效性。

### 优先级

本规则通用于优先级的概念。

- STL 重载比较符号操作，只能重载小于（<）号
- 优先队列比较的是元素优先级，优先级高的先出队（即小于号比较的数字的意义是优先级大小）
	比如 int 类型默认较大的数优先级高，先出队。（数字小则优先级小，不优先）

注意：优先级相等的元素的入队出队顺序不确定

顺序严格限定：重载为多级比较。对元素顺序，特别是相等元素顺序严格限定，考虑增加参数，进行二级，多级比较。

## 链表

### 数组表示法（静态链表）





## 二叉树

### 区间表示法

对于用中序遍历顺序表示，用**二维数组**进行**概念存储**的二叉树，可使用区间确定二叉树的某个部分。

常用于树上的搜索、区间动规、树形动规中。

- $L$ 代表区间左端点。
- $R$ 代表区间右端点。
- $root[L][R]$ 代表某个区间的根。
- 设 $r = root[L][R]$，有其左子树为 $tree[L][r-1]$，右子树为 $tree[r+1][R]$。
- 当 $L = R$ 时，$tree[L][R]$ 即为叶子结点。
- 当 $L = R + 1$ 时，即 $tree[L][R-1],\ tree[L+1][R]$ 是空结点。

为什么 $L = R+1$ 时是空子树？

$L = R$ 时是叶子结点，于是其左子树为：$L,\ R-1$，其右子树为：$L+1,\ R$，而叶子结点的左右子树自然是空结点。

初始化时注意叶子结点与空结点都要初始化。

### 堆表示法

用**一维数组**，以堆的形式存储二叉树。

#### 下标变换

- x 结点的：（下标从 $1$ 开始较简便）
	- 父亲：```tree[x/2]```
	- 左孩子：```tree[2*x]```
	- 右孩子：```tree[2*x+1]```

#### 初始化

- 原始数据只在最底层的叶子上，设数据量为 $N$ 。

	详见《线段树》

	- 采用递归法建树，则数组大小一般要在 $4N$ 以上。

		先递归深入，触底后在回溯的过程中赋值。

	-  采用迭代法建树，则数组大小一般要在 $2N$ 以上。

		先计算出初始叶子的位置，然后依序赋值。

- 原始数据覆盖全树，设数据量为 $N$ 。

	- 采用迭代法建树，则数组大小要在 $N$ 以上。



## 集合

### multiset

一级比较，将小于号重载为以下符号时：

- 小于（<）保证相等元素先进先出
- 小于等于（<=）保证相等元素先进后出

- 大于（>）保证相等元素先进先出
- 大于等于（>=）保证相等元素先进后出